<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pumpkin AI - Stream</title>
  <style>
    body { background:#111; color:#eee; font-family: Arial, sans-serif; margin:0; }
    .page { display:flex; align-items:flex-start; justify-content:center; gap:28px; max-width:1200px; margin:0 auto; padding:24px; box-sizing:border-box; }
    .story-pane { flex:1; max-width:45%; text-align:left; }
    .story-heading { font-size:38px; font-weight:700; line-height:1.3; margin:0 0 28px; }
    .story-box { border:2px solid #444; border-radius:16px; min-height:220px; background:rgba(255,255,255,0.04); color:#f5f5f5; font-size:30px; padding:28px; box-sizing:border-box; word-wrap:break-word; white-space:pre-wrap; }
    .story-box.story-box--empty { color:#888; font-style:italic; }
    .video-pane { flex:1; max-width:55%; text-align:center; }
    img { max-width: 100%; height: auto; border: 1px solid #333; border-radius:12px; }
    .controls { margin-top: 10px }
    button { margin: 0 6px; padding: 8px 14px; font-size: 14px }
    .controls-row { margin-bottom:8px; }
    h1 { margin-top:0; }
    @media (max-width: 900px) {
      .page { flex-direction: column; align-items: stretch; }
      .story-pane, .video-pane { max-width:100%; }
      .story-heading { font-size:32px; }
      .story-box { font-size:24px; }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="story-pane">
      <div class="story-heading">I am a [witch, pumpkin, devil] and I love [chips, chocolate, candy]</div>
      <div id="storyBox" class="story-box story-box--empty">Waiting for story...</div>
    </div>
    <div class="video-pane">
      <h1>Pumpkin AI</h1>
      <img id="stream" src="/stream" alt="video stream">

      <div class="controls">
        <div class="controls-row">
          <button id="modeBtn" onclick="toggleMode()">Switch to Dev</button>
          <span id="prodControls" style="display:inline-block">
            <button id="snapshotBtn" onclick="triggerSnapshot()">Snapshot</button>
            <button id="resetBtn" onclick="resetProd()">Reset</button>
          </span>
          <span id="devControls" style="display:none">
            <span id="overlayButtons" style="display:inline-block"></span>
            <button id="clearOverlaysBtn" onclick="clearOverlays()">Disable All Overlays</button>
            <span id="activeOverlayList" style="margin-left:10px"></span>
            <button id="nudgeBtn" onclick="toggleNudge()">Enable Nudge Mode</button>
          </span>
        </div>
      </div>
      <div id="nudgePanel" style="display:none; margin-top:14px;">
    <div style="margin-bottom:6px;"><strong>Nudge Target:</strong> <span id="nudgeTargetLabel">none</span></div>
    <div id="nudgeConfigValues" style="margin-bottom:6px; font-size:13px; color:#ccc;">config not loaded</div>
    <div style="margin-bottom:8px;">
      <label style="margin-right:10px;">Offset X (%):
        <input type="number" id="offsetXInput" step="1" min="-200" max="200" oninput="onOffsetInput('x', this.value)">
      </label>
      <label>Offset Y (%):
        <input type="number" id="offsetYInput" step="1" min="-200" max="200" oninput="onOffsetInput('y', this.value)">
      </label>
    </div>
    <div>
      <button onclick="applyNudge('offset_up')">Up</button>
    </div>
    <div style="margin-top:4px;">
      <button onclick="applyNudge('offset_left')">Left</button>
      <button onclick="applyNudge('offset_down')">Down</button>
      <button onclick="applyNudge('offset_right')">Right</button>
    </div>
    <div style="margin-top:4px;">
      <button onclick="applyNudge('scale_down')">Scale -</button>
      <button onclick="applyNudge('scale_up')">Scale +</button>
      <button onclick="applyNudge('anchor_left')">Anchor -</button>
      <button onclick="applyNudge('anchor_right')">Anchor +</button>
      <button onclick="applyNudge('y_offset_up')">Y Off -</button>
      <button onclick="applyNudge('y_offset_down')">Y Off +</button>
    </div>
    <div style="margin-top:4px;">
      <button onclick="applyNudge('save')">Save Config</button>
      <button onclick="applyNudge('reload')">Reload</button>
    </div>
    <div id="nudgeNotice" style="margin-top:6px; font-size:12px; color:#aaa;"></div>
  </div>
    </div>
  </div>

  <script>
  let currentMode = 'prod';
  let prodFrozen = false;
  let prodWaiting = false;
  let overlayCatalog = [];
  let activeOverlays = [];
  let nudgeMode = false;
  let nudgeTarget = null;
  let nudgeConfig = null;
  let nudgeMessage = '';
  let nudgeCooldownUntil = 0;
  const offsetSetTimers = { x: null, y: null };
  let storyText = '';

  function applyNudge(action, value){
    if(!nudgeMode || !action){
      return;
    }
    const now = Date.now();
    const hasPayload = value !== undefined;
    if(!hasPayload){
      if(now < nudgeCooldownUntil){
        return;
      }
      nudgeCooldownUntil = now + 200;
    }
    const opts = {method:'POST'};
    if(hasPayload){
      opts.headers = {'Content-Type':'application/json'};
      opts.body = JSON.stringify({value});
    }
    fetch('/api/nudge/'+encodeURIComponent(action), opts)
      .then(r=>r.json())
      .then(res=>{
        if(res.nudge !== undefined){
          nudgeMode = !!res.nudge;
        }
        if(res.target !== undefined){
          nudgeTarget = res.target;
        }
        if(Object.prototype.hasOwnProperty.call(res, 'config')){
          nudgeConfig = res.config;
        }
        if(res.nudge_message || res.message){
          nudgeMessage = res.nudge_message || res.message || '';
        }
        updateNudgePanel();
        if(res.error){
          console.error(res.error);
        }
      })
      .catch(()=>{});
  }

  function updateNudgePanel(){
    const panel = document.getElementById('nudgePanel');
    const label = document.getElementById('nudgeTargetLabel');
    const cfgBox = document.getElementById('nudgeConfigValues');
    const notice = document.getElementById('nudgeNotice');
    if(!panel || !label || !cfgBox || !notice){
      return;
    }
    if(!nudgeMode || currentMode !== 'dev'){
      panel.style.display = 'none';
      updateOffsetInputs();
      return;
    }
    panel.style.display = 'block';
    label.textContent = nudgeTarget ? stripExt(nudgeTarget) : 'none';
    renderNudgeConfigSummary();
    notice.textContent = nudgeMessage || '';
    updateOffsetInputs();
  }
  function toggleNudge(){
    fetch('/api/toggle_nudge', {method:'POST'})
      .then(r=>r.json())
      .then(s=>{
        if(typeof s.nudge === 'boolean'){
          nudgeMode = s.nudge;
        }
        if(s.target !== undefined){
          nudgeTarget = s.target;
        }
        if(Object.prototype.hasOwnProperty.call(s, 'config')){
          nudgeConfig = s.config;
        }
        if(s.nudge_message || s.message){
          nudgeMessage = s.nudge_message || s.message || '';
        }
        updateUi();
      })
      .catch(()=>{});
  }


  function stripExt(name){
    return name ? name.replace(/\.png$/i, '') : name;
  }

  function rebuildOverlayButtons(list){
    const container = document.getElementById('overlayButtons');
    if(!container) return;
    container.innerHTML = '';
    list.forEach(name => {
      const label = stripExt(name);
      const btn = document.createElement('button');
      btn.textContent = label;
      btn.onclick = () => addOverlay(label);
      container.appendChild(btn);
    });
  }

  function addOverlay(name){
    fetch('/api/overlay/'+encodeURIComponent(name), {method:'POST'})
      .then(r=>r.json())
      .then(s=>{
        if(s.active_overlays){
          activeOverlays = s.active_overlays;
        }
        updateUi();
      })
      .catch(()=>{});
  }

  function clearOverlays(){
    fetch('/api/overlay/reset', {method:'POST'})
      .then(r=>r.json())
      .then(s=>{
        if(s.active_overlays){
          activeOverlays = s.active_overlays;
        }
        updateUi();
      })
      .catch(()=>{});
  }

  function updateActiveOverlayLabel(){
    const el = document.getElementById('activeOverlayList');
    if(!el) return;
    if(currentMode === 'prod'){
      el.textContent = '';
      return;
    }
    if(activeOverlays.length){
      el.textContent = 'Active: ' + activeOverlays.map(stripExt).join(', ');
    } else {
      el.textContent = 'Active: none';
    }
  }

  function triggerSnapshot(){
    fetch('/api/prod_snapshot', {method:'POST'})
      .then(()=>{
        prodFrozen = false;
        prodWaiting = true;
        updateUi();
      });
  }

  function resetProd(){
    fetch('/api/prod_reset', {method:'POST'})
      .then(()=>{
        prodFrozen = false;
        prodWaiting = false;
        updateUi();
      });
  }

  function updateUi(){
    const modeBtn = document.getElementById('modeBtn');
    const devControls = document.getElementById('devControls');
    const prodControls = document.getElementById('prodControls');
    const snapshotBtn = document.getElementById('snapshotBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fpsBox = document.getElementById('fpsBox');
    const clearBtn = document.getElementById('clearOverlaysBtn');
    const nudgeBtn = document.getElementById('nudgeBtn');

    if(currentMode === 'prod'){
      modeBtn.textContent = 'Switch to Dev';
      devControls.style.display = 'none';
      prodControls.style.display = 'inline-block';
      snapshotBtn.disabled = prodFrozen || prodWaiting;
      resetBtn.disabled = !prodFrozen && !prodWaiting;
      if(fpsBox){
        fpsBox.style.display = 'none';
      }
    } else {
      modeBtn.textContent = 'Switch to Prod';
      devControls.style.display = 'inline-block';
      prodControls.style.display = 'none';
      if(fpsBox){
        fpsBox.style.display = 'block';
      }
    }
    if(clearBtn){
      clearBtn.disabled = activeOverlays.length === 0;
    }
    if(nudgeBtn){
      if(currentMode === 'prod'){
        nudgeBtn.disabled = true;
        nudgeBtn.textContent = 'Enable Nudge Mode';
      } else {
        nudgeBtn.disabled = false;
        nudgeBtn.textContent = nudgeMode ? 'Disable Nudge Mode' : 'Enable Nudge Mode';
      }
    }
    updateActiveOverlayLabel();
    updateNudgePanel();
  }

  function formatOffset(value){
    const num = Number(value);
    if(!Number.isFinite(num)){
      return '0';
    }
    return num.toFixed(3).replace(/\.0+$/,'').replace(/\.([0-9]*[1-9])0+$/,'.$1');
  }

  function renderNudgeConfigSummary(){
    const cfgBox = document.getElementById('nudgeConfigValues');
    if(!cfgBox){
      return;
    }
    if(nudgeConfig){
      cfgBox.textContent = `scale ${nudgeConfig.scale.toFixed(3)} | y ${nudgeConfig.y_offset.toFixed(3)} | anchor ${nudgeConfig.x_anchor.toFixed(3)} | offx ${formatOffset(nudgeConfig.offset_x)}% | offy ${formatOffset(nudgeConfig.offset_y)}%`;
    } else {
      cfgBox.textContent = 'config not loaded';
    }
  }

  function updateOffsetInputs(){
    const inputX = document.getElementById('offsetXInput');
    const inputY = document.getElementById('offsetYInput');
    if(!inputX || !inputY){
      return;
    }
    if(!nudgeMode || currentMode !== 'dev'){
      inputX.disabled = true;
      inputY.disabled = true;
      return;
    }
    if(!nudgeConfig){
      inputX.value = '';
      inputY.value = '';
      inputX.disabled = true;
      inputY.disabled = true;
      return;
    }
    inputX.disabled = false;
    inputY.disabled = false;
    const active = document.activeElement;
    if(active !== inputX){
      inputX.value = formatOffset(nudgeConfig.offset_x ?? 0);
    }
    if(active !== inputY){
      inputY.value = formatOffset(nudgeConfig.offset_y ?? 0);
    }
  }

  function onOffsetInput(axis, raw){
    if(currentMode !== 'dev' || !nudgeMode || !nudgeConfig){
      return;
    }
    if(offsetSetTimers[axis]){
      clearTimeout(offsetSetTimers[axis]);
    }
    const parsed = parseFloat(raw);
    if(Number.isNaN(parsed)){
      return;
    }
    const value = Math.round(parsed * 1000) / 1000;
    if(axis === 'x'){
      nudgeConfig.offset_x = value;
    } else {
      nudgeConfig.offset_y = value;
    }
    renderNudgeConfigSummary();
    updateOffsetInputs();
    offsetSetTimers[axis] = setTimeout(()=>{
      applyNudge(axis === 'x' ? 'set_offset_x' : 'set_offset_y', value);
      offsetSetTimers[axis] = null;
    }, 200);
  }

  function updateStoryBox(){
    const box = document.getElementById('storyBox');
    if(!box){
      return;
    }
    const text = (storyText || '').trim();
    if(text){
      box.textContent = text;
      box.classList.remove('story-box--empty');
    } else {
      box.textContent = 'Waiting for story...';
      box.classList.add('story-box--empty');
    }
  }

  function fetchStory(){
    fetch('/api/story')
      .then(r=>r.json())
      .then(data=>{
        if(data && typeof data.text === 'string'){
          if(data.text !== storyText){
            storyText = data.text;
            updateStoryBox();
          }
        }
      })
      .catch(()=>{});
  }

  // Poll status every second
  setInterval(()=>{
    fetch('/api/status')
      .then(r=>r.json())
      .then(s=>{
        document.getElementById('fps').textContent = s.fps + ' FPS';
        const catalog = Array.isArray(s.overlays) ? s.overlays : [];
        if(JSON.stringify(catalog) !== JSON.stringify(overlayCatalog)){
          overlayCatalog = catalog;
          rebuildOverlayButtons(overlayCatalog);
        }
        activeOverlays = Array.isArray(s.active_overlays) ? s.active_overlays : [];
        nudgeMode = !!s.nudge;
        if(Object.prototype.hasOwnProperty.call(s, 'nudge_target')){
          nudgeTarget = s.nudge_target;
        }
        if(Object.prototype.hasOwnProperty.call(s, 'nudge_config')){
          nudgeConfig = s.nudge_config;
        }
        nudgeMessage = s.nudge_message || '';
        if(Object.prototype.hasOwnProperty.call(s, 'story_text')){
          if(s.story_text !== storyText){
            storyText = s.story_text || '';
            updateStoryBox();
          }
        }
        currentMode = s.mode;
        prodFrozen = !!s.prod_frozen;
        prodWaiting = !!s.prod_waiting;
        updateUi();
      })
      .catch(()=>{});
  }, 1000);

  setInterval(fetchStory, 3000);
  fetchStory();
  updateStoryBox();

  function toggleMode(){
    const next = currentMode === 'prod' ? 'dev' : 'prod';
    fetch('/api/set_mode?mode='+next, {method:'POST'}).then(()=>{
      currentMode = next;
      if(next === 'dev'){
        prodFrozen = false;
        prodWaiting = false;
      }
      updateUi();
    });
  }

  // initialize UI to match defaults
  updateUi();
  updateNudgePanel();
  </script>
  <div id="fpsBox" style="position:fixed; right:10px; top:10px; color:#0f0; font-weight:bold">FPS: <span id="fps">-</span></div>
</body>
</html>