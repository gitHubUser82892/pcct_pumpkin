<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pumpkin AI - Stream</title>
  <style>
    body { background:#111; color:#eee; font-family: Arial, sans-serif; margin:0; }
  .page { display:flex; align-items:flex-start; justify-content:space-between; gap:24px; width:100%; max-width:none; margin:0 auto; padding:20px 20px; box-sizing:border-box; }
    .story-pane { flex:1; max-width:50%; text-align:left; }
  .story-sentence { font-size:34px; font-weight:500; line-height:1.3; display:flex; flex-wrap:wrap; align-items:center; gap:16px; margin-bottom:28px; color:#ff7518; }
    .story-sentence span { white-space:nowrap; }
    .story-sentence .story-input,
    .story-sentence .story-select { font-size:34px; padding:20px 24px; border-radius:16px; border:2px solid #555; background:#1a1a1a; color:#fdfdfd; min-width:240px; box-sizing:border-box; }
    .story-sentence .story-select { min-width:240px; }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
    .story-box { border:2px solid #444; border-radius:18px; min-height:280px; background:rgba(255,255,255,0.04); color:#f5f5f5; font-size:34px; padding:36px; box-sizing:border-box; word-wrap:break-word; white-space:pre-wrap; }
    .story-box.story-box--empty { color:#888; font-style:italic; }
    .story-actions { display:flex; flex-wrap:wrap; gap:18px; margin-bottom:26px; }
  .story-actions button { font-size:32px; padding:20px 34px; border-radius:16px; background:#ff7518; color:#111; border:none; cursor:pointer; font-weight:700; margin:0; }
    .story-actions button:hover { background:#ff8b3d; }
    .video-pane { flex:1; max-width:50%; text-align:center; }
    img { max-width: 100%; height: auto; border: 1px solid #333; border-radius:12px; }
    .controls { margin-top: 10px }
    button { margin: 0 6px; padding: 8px 14px; font-size: 14px }
    .controls-row { margin-bottom:8px; }
    h1 { margin-top:0; }
    @media (max-width: 900px) {
  .page { flex-direction: column; align-items: stretch; padding:18px 16px; }
      .story-pane, .video-pane { max-width:100%; }
  .story-sentence { font-size:26px; font-weight:500; color:#ff7518; }
    .story-sentence .story-input,
    .story-sentence .story-select { font-size:26px; padding:16px 18px; min-width:180px; }
    .story-box { font-size:28px; }
    .story-actions button { width:100%; }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="story-pane">
      <div class="story-sentence">
        <span>My name is</span>
        <label class="sr-only" for="storyNameInput">Enter visitor name</label>
        <input id="storyNameInput" class="story-input" type="text" placeholder="Enter name" oninput="onStoryNameInput(this.value)" />
        <span>I am a</span>
        <label class="sr-only" for="storyCharacterSelect">Select character</label>
        <select id="storyCharacterSelect" class="story-select" onchange="onCharacterSelect(this.value)">
          <option value="">character</option>
          <option value="witch">witch</option>
          <option value="pumpkin">pumpkin</option>
          <option value="devil">devil</option>
        </select>
        <span>and I love</span>
        <label class="sr-only" for="storyFoodSelect">Select favorite food</label>
        <select id="storyFoodSelect" class="story-select" onchange="onFoodSelect(this.value)">
          <option value="">food</option>
          <option value="chips">chips</option>
          <option value="chocolate">chocolate</option>
          <option value="candy">candy</option>
        </select>
        <span>.</span>
      </div>
      <div class="story-actions">
        <button type="button" onclick="handleGenerateStory()">Generate Story</button>
      </div>
      <div id="storyBox" class="story-box story-box--empty">Waiting for story...</div>
    </div>
    <div class="video-pane">
      <h1 style="color:#ff7518;">Pumpkin AI</h1>
      <img id="stream" src="/stream" alt="video stream">

      <div class="controls">
        <div class="controls-row">
          <button id="modeBtn" onclick="toggleMode()">Switch to Dev</button>
          <span id="prodControls" style="display:inline-block">
            <button id="snapshotBtn" onclick="triggerSnapshot()">Snapshot</button>
          </span>
          <span id="devControls" style="display:none">
            <span id="overlayButtons" style="display:inline-block"></span>
            <button id="clearOverlaysBtn" onclick="clearOverlays()">Disable All Overlays</button>
            <span id="activeOverlayList" style="margin-left:10px"></span>
            <button id="nudgeBtn" onclick="toggleNudge()">Enable Nudge Mode</button>
          </span>
        </div>
      </div>
      <div id="nudgePanel" style="display:none; margin-top:14px;">
    <div style="margin-bottom:6px;"><strong>Nudge Target:</strong> <span id="nudgeTargetLabel">none</span></div>
    <div id="nudgeConfigValues" style="margin-bottom:6px; font-size:13px; color:#ccc;">config not loaded</div>
    <div style="margin-bottom:8px;">
      <label style="margin-right:10px;">Offset X (%):
        <input type="number" id="offsetXInput" step="1" min="-200" max="200" oninput="onOffsetInput('x', this.value)">
      </label>
      <label>Offset Y (%):
        <input type="number" id="offsetYInput" step="1" min="-200" max="200" oninput="onOffsetInput('y', this.value)">
      </label>
    </div>
    <div>
      <button onclick="applyNudge('offset_up')">Up</button>
    </div>
    <div style="margin-top:4px;">
      <button onclick="applyNudge('offset_left')">Left</button>
      <button onclick="applyNudge('offset_down')">Down</button>
      <button onclick="applyNudge('offset_right')">Right</button>
    </div>
    <div style="margin-top:4px;">
      <button onclick="applyNudge('scale_down')">Scale -</button>
      <button onclick="applyNudge('scale_up')">Scale +</button>
      <button onclick="applyNudge('anchor_left')">Anchor -</button>
      <button onclick="applyNudge('anchor_right')">Anchor +</button>
      <button onclick="applyNudge('y_offset_up')">Y Off -</button>
      <button onclick="applyNudge('y_offset_down')">Y Off +</button>
    </div>
    <div style="margin-top:4px;">
      <button onclick="applyNudge('save')">Save Config</button>
      <button onclick="applyNudge('reload')">Reload</button>
    </div>
    <div id="nudgeNotice" style="margin-top:6px; font-size:12px; color:#aaa;"></div>
  </div>
    </div>
  </div>

  <script>
  let currentMode = 'prod';
  let prodFrozen = false;
  let prodWaiting = false;
  let overlayCatalog = [];
  let activeOverlays = [];
  let nudgeMode = false;
  let nudgeTarget = null;
  let nudgeConfig = null;
  let nudgeMessage = '';
  let nudgeCooldownUntil = 0;
  const offsetSetTimers = { x: null, y: null };
  let storyText = '';
  let storyNameInput = '';
  let storyCharacter = '';
  let storyFood = '';
  let storyGenerating = false;
  const characterOverlayMap = { witch: 'YW', pumpkin: 'YP', devil: 'YD' };
  const foodOverlayMap = { chips: 'XC', chocolate: 'XCH', candy: 'XCA' };
  let characterOverlayPrefix = '';
  let foodOverlayPrefix = '';
  let selectedCharacterOverlay = null;
  let selectedFoodOverlay = null;
  let overlaySyncPromise = Promise.resolve();
  let storyOverlayInFlight = false;

  function applyNudge(action, value){
    if(!nudgeMode || !action){
      return;
    }
    const now = Date.now();
    const hasPayload = value !== undefined;
    if(!hasPayload){
      if(now < nudgeCooldownUntil){
        return;
      }
      nudgeCooldownUntil = now + 200;
    }
    const opts = {method:'POST'};
    if(hasPayload){
      opts.headers = {'Content-Type':'application/json'};
      opts.body = JSON.stringify({value});
    }
    fetch('/api/nudge/'+encodeURIComponent(action), opts)
      .then(r=>r.json())
      .then(res=>{
        if(res.nudge !== undefined){
          nudgeMode = !!res.nudge;
        }
        if(res.target !== undefined){
          nudgeTarget = res.target;
        }
        if(Object.prototype.hasOwnProperty.call(res, 'config')){
          nudgeConfig = res.config;
        }
        if(res.nudge_message || res.message){
          nudgeMessage = res.nudge_message || res.message || '';
        }
        updateNudgePanel();
        if(res.error){
          console.error(res.error);
        }
      })
      .catch(()=>{});
  }

  function updateNudgePanel(){
    const panel = document.getElementById('nudgePanel');
    const label = document.getElementById('nudgeTargetLabel');
    const cfgBox = document.getElementById('nudgeConfigValues');
    const notice = document.getElementById('nudgeNotice');
    if(!panel || !label || !cfgBox || !notice){
      return;
    }
    if(!nudgeMode || currentMode !== 'dev'){
      panel.style.display = 'none';
      updateOffsetInputs();
      return;
    }
    panel.style.display = 'block';
    label.textContent = nudgeTarget ? stripExt(nudgeTarget) : 'none';
    renderNudgeConfigSummary();
    notice.textContent = nudgeMessage || '';
    updateOffsetInputs();
  }
  function toggleNudge(){
    fetch('/api/toggle_nudge', {method:'POST'})
      .then(r=>r.json())
      .then(s=>{
        if(typeof s.nudge === 'boolean'){
          nudgeMode = s.nudge;
        }
        if(s.target !== undefined){
          nudgeTarget = s.target;
        }
        if(Object.prototype.hasOwnProperty.call(s, 'config')){
          nudgeConfig = s.config;
        }
        if(s.nudge_message || s.message){
          nudgeMessage = s.nudge_message || s.message || '';
        }
        updateUi();
      })
      .catch(()=>{});
  }


  function stripExt(name){
    return name ? name.replace(/\.png$/i, '') : name;
  }

  function rebuildOverlayButtons(list){
    const container = document.getElementById('overlayButtons');
    if(!container) return;
    container.innerHTML = '';
    list.forEach(name => {
      const label = stripExt(name);
      const btn = document.createElement('button');
      btn.textContent = label;
      btn.onclick = () => addOverlay(label);
      container.appendChild(btn);
    });
  }

  function addOverlay(name){
    return fetch('/api/overlay/'+encodeURIComponent(name), {method:'POST'})
      .then(r=>r.json().catch(()=>({})))
      .then(s=>{
        if(s && Array.isArray(s.active_overlays)){
          activeOverlays = s.active_overlays;
        }
        updateUi();
        return true;
      })
      .catch(err=>{
        console.error('Failed to add overlay', err);
        return false;
      });
  }

  function clearOverlays(){
    return fetch('/api/overlay/reset', {method:'POST'})
      .then(r=>r.json().catch(()=>({})))
      .then(s=>{
        if(s && Array.isArray(s.active_overlays)){
          activeOverlays = s.active_overlays;
        } else {
          activeOverlays = [];
        }
        updateUi();
        return true;
      })
      .catch(err=>{
        console.error('Failed to clear overlays', err);
        return false;
      });
  }

  function overlayMatchesPrefix(name, prefix){
    if(!name || !prefix){
      return false;
    }
    const upperName = name.toUpperCase();
    const upperPrefix = prefix.toUpperCase();
    if(!upperName.startsWith(upperPrefix)){
      return false;
    }
    if(upperPrefix === 'XC'){
      const nextChar = upperName.charAt(upperPrefix.length);
      return nextChar >= '0' && nextChar <= '9';
    }
    return true;
  }

  function pickOverlayForPrefix(prefix, current){
    if(!prefix){
      return null;
    }
    const upper = prefix.toUpperCase();
    const matches = overlayCatalog.filter(name => overlayMatchesPrefix(name, upper));
    if(!matches.length){
      if(overlayCatalog.length){
        console.warn('No overlays found for prefix', prefix);
      }
      return null;
    }
    if(current && matches.includes(current)){
      return current;
    }
    const index = Math.floor(Math.random() * matches.length);
    return matches[index];
  }

  function applyStoryOverlays(){
    overlaySyncPromise = overlaySyncPromise
      .then(()=>{
        storyOverlayInFlight = true;
        const desired = [];

        if(characterOverlayPrefix){
          const choice = pickOverlayForPrefix(characterOverlayPrefix, selectedCharacterOverlay);
          selectedCharacterOverlay = choice;
          if(choice){
            desired.push(choice);
          }
        } else {
          selectedCharacterOverlay = null;
        }

        if(foodOverlayPrefix){
          const choice = pickOverlayForPrefix(foodOverlayPrefix, selectedFoodOverlay);
          selectedFoodOverlay = choice;
          if(choice){
            desired.push(choice);
          }
        } else {
          selectedFoodOverlay = null;
        }

        if(!desired.length){
          selectedCharacterOverlay = null;
          selectedFoodOverlay = null;
          return clearOverlays();
        }

        return clearOverlays()
          .then(()=>{
            return desired.reduce((chain, name)=>{
              const base = stripExt(name);
              return chain.then(()=>addOverlay(base));
            }, Promise.resolve());
          });
      })
      .then(result=>{
        storyOverlayInFlight = false;
        return result;
      })
      .catch(err=>{
        storyOverlayInFlight = false;
        console.error('Story overlay update failed:', err);
      });
    return overlaySyncPromise;
  }

  function onStoryNameInput(value){
    storyNameInput = (value || '').trim();
  }

  function onCharacterSelect(value){
    const normalized = value || '';
    storyCharacter = normalized;
    const newPrefix = (characterOverlayMap[normalized] || '').toUpperCase();
    if(newPrefix !== characterOverlayPrefix){
      characterOverlayPrefix = newPrefix;
      if(!newPrefix || !overlayMatchesPrefix(selectedCharacterOverlay, newPrefix)){
        selectedCharacterOverlay = null;
      }
    } else if(newPrefix && selectedCharacterOverlay && !overlayMatchesPrefix(selectedCharacterOverlay, newPrefix)){
      selectedCharacterOverlay = null;
    }
    applyStoryOverlays();
  }

  function onFoodSelect(value){
    const normalized = value || '';
    storyFood = normalized;
    const newPrefix = (foodOverlayMap[normalized] || '').toUpperCase();
    if(newPrefix !== foodOverlayPrefix){
      foodOverlayPrefix = newPrefix;
      if(!newPrefix || !overlayMatchesPrefix(selectedFoodOverlay, newPrefix)){
        selectedFoodOverlay = null;
      }
    } else if(newPrefix && selectedFoodOverlay && !overlayMatchesPrefix(selectedFoodOverlay, newPrefix)){
      selectedFoodOverlay = null;
    }
    applyStoryOverlays();
  }

  function updateActiveOverlayLabel(){
    const el = document.getElementById('activeOverlayList');
    if(!el) return;
    if(currentMode === 'prod'){
      el.textContent = '';
      return;
    }
    if(activeOverlays.length){
      el.textContent = 'Active: ' + activeOverlays.map(stripExt).join(', ');
    } else {
      el.textContent = 'Active: none';
    }
  }

  function triggerSnapshot(){
    return fetch('/api/prod_snapshot', {method:'POST'})
      .then(()=>{
        prodFrozen = false;
        prodWaiting = true;
        updateUi();
      })
      .catch(err=>{
        console.error('Snapshot request failed:', err);
      });
  }

  function unfreezeProd(){
    return fetch('/api/prod_reset', {method:'POST'})
      .then(()=>{
        prodFrozen = false;
        prodWaiting = false;
        updateUi();
      });
  }

  function resetProd(){
    return unfreezeProd()
      .then(()=>{
        storyText = '';
        updateStoryBox();
        storyCharacter = '';
        storyFood = '';
        characterOverlayPrefix = '';
        foodOverlayPrefix = '';
        selectedCharacterOverlay = null;
        selectedFoodOverlay = null;

        const charEl = document.getElementById('storyCharacterSelect');
        if(charEl){
          charEl.value = '';
        }
        const foodEl = document.getElementById('storyFoodSelect');
        if(foodEl){
          foodEl.value = '';
        }

        const overlayPromise = applyStoryOverlays();
        const storyClearPromise = fetch('/api/story', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({text: ''}),
        }).catch(err=>{
          console.error('Story clear request failed:', err);
        });

        return Promise.all([overlayPromise, storyClearPromise]);
      })
      .then(()=>{
        updateUi();
      })
      .catch(err=>{
        console.error('Reset request failed:', err);
        updateUi();
      });
  }

  function updateUi(){
    const modeBtn = document.getElementById('modeBtn');
    const devControls = document.getElementById('devControls');
    const prodControls = document.getElementById('prodControls');
    const snapshotBtn = document.getElementById('snapshotBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fpsBox = document.getElementById('fpsBox');
    const clearBtn = document.getElementById('clearOverlaysBtn');
    const nudgeBtn = document.getElementById('nudgeBtn');

    if(currentMode === 'prod'){
      modeBtn.textContent = 'Switch to Dev';
      devControls.style.display = 'none';
      prodControls.style.display = 'inline-block';
      snapshotBtn.disabled = prodFrozen || prodWaiting;
      if(fpsBox){
        fpsBox.style.display = 'none';
      }
    } else {
      modeBtn.textContent = 'Switch to Prod';
      devControls.style.display = 'inline-block';
      prodControls.style.display = 'none';
      if(fpsBox){
        fpsBox.style.display = 'block';
      }
    }
    if(resetBtn){
      resetBtn.disabled = false;
    }
    if(clearBtn){
      clearBtn.disabled = activeOverlays.length === 0;
    }
    if(nudgeBtn){
      if(currentMode === 'prod'){
        nudgeBtn.disabled = true;
        nudgeBtn.textContent = 'Enable Nudge Mode';
      } else {
        nudgeBtn.disabled = false;
        nudgeBtn.textContent = nudgeMode ? 'Disable Nudge Mode' : 'Enable Nudge Mode';
      }
    }
    updateActiveOverlayLabel();
    updateNudgePanel();
  }

  function formatOffset(value){
    const num = Number(value);
    if(!Number.isFinite(num)){
      return '0';
    }
    return num.toFixed(3).replace(/\.0+$/,'').replace(/\.([0-9]*[1-9])0+$/,'.$1');
  }

  function renderNudgeConfigSummary(){
    const cfgBox = document.getElementById('nudgeConfigValues');
    if(!cfgBox){
      return;
    }
    if(nudgeConfig){
      cfgBox.textContent = `scale ${nudgeConfig.scale.toFixed(3)} | y ${nudgeConfig.y_offset.toFixed(3)} | anchor ${nudgeConfig.x_anchor.toFixed(3)} | offx ${formatOffset(nudgeConfig.offset_x)}% | offy ${formatOffset(nudgeConfig.offset_y)}%`;
    } else {
      cfgBox.textContent = 'config not loaded';
    }
  }

  function updateOffsetInputs(){
    const inputX = document.getElementById('offsetXInput');
    const inputY = document.getElementById('offsetYInput');
    if(!inputX || !inputY){
      return;
    }
    if(!nudgeMode || currentMode !== 'dev'){
      inputX.disabled = true;
      inputY.disabled = true;
      return;
    }
    if(!nudgeConfig){
      inputX.value = '';
      inputY.value = '';
      inputX.disabled = true;
      inputY.disabled = true;
      return;
    }
    inputX.disabled = false;
    inputY.disabled = false;
    const active = document.activeElement;
    if(active !== inputX){
      inputX.value = formatOffset(nudgeConfig.offset_x ?? 0);
    }
    if(active !== inputY){
      inputY.value = formatOffset(nudgeConfig.offset_y ?? 0);
    }
  }

  function onOffsetInput(axis, raw){
    if(currentMode !== 'dev' || !nudgeMode || !nudgeConfig){
      return;
    }
    if(offsetSetTimers[axis]){
      clearTimeout(offsetSetTimers[axis]);
    }
    const parsed = parseFloat(raw);
    if(Number.isNaN(parsed)){
      return;
    }
    const value = Math.round(parsed * 1000) / 1000;
    if(axis === 'x'){
      nudgeConfig.offset_x = value;
    } else {
      nudgeConfig.offset_y = value;
    }
    renderNudgeConfigSummary();
    updateOffsetInputs();
    offsetSetTimers[axis] = setTimeout(()=>{
      applyNudge(axis === 'x' ? 'set_offset_x' : 'set_offset_y', value);
      offsetSetTimers[axis] = null;
    }, 200);
  }

  function updateStoryBox(){
    const box = document.getElementById('storyBox');
    if(!box){
      return;
    }
    const text = (storyText || '').trim();
    if(text){
      box.textContent = text;
      box.classList.remove('story-box--empty');
    } else {
      box.textContent = 'Waiting for story...';
      box.classList.add('story-box--empty');
    }
  }

  function fetchStory(){
    fetch('/api/story')
      .then(r=>r.json())
      .then(data=>{
        if(data && typeof data.text === 'string'){
          if(data.text !== storyText){
            storyText = data.text;
            updateStoryBox();
          }
        }
      })
      .catch(()=>{});
  }

  function handleGenerateStory(){
    if(storyGenerating){
      return;
    }
    const button = document.querySelector('.story-actions button');
    storyGenerating = true;
    if(button){
      button.disabled = true;
      button.textContent = 'Generating...';
    }

    const box = document.getElementById('storyBox');
    if(box){
      box.textContent = 'Generating story...';
      box.classList.remove('story-box--empty');
    }

    if(currentMode === 'prod'){
      let chain = Promise.resolve();
      if(prodFrozen){
        chain = chain.then(()=>unfreezeProd());
      }
      if(!prodWaiting){
        chain = chain.then(()=>triggerSnapshot());
      }
      chain.catch(err=>{
        console.error('Snapshot preparation failed:', err);
      });
    }

    const payload = {
      name: storyNameInput,
      character: storyCharacter,
      food: storyFood,
    };

    fetch('/api/story_generate', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload),
    })
      .then(r => r.json())
      .then(data => {
        if(data && typeof data.text === 'string'){
          storyText = data.text;
          updateStoryBox();
          return;
        }
        if(data && data.error){
          console.error('Story generation failed:', data.error);
          if(box){
            box.textContent = `Story generation failed: ${data.error}`;
          }
        }
      })
      .catch(err => {
        console.error('Story generation error:', err);
        if(box){
          box.textContent = 'Story generation failed: network error.';
        }
      })
      .finally(() => {
        storyGenerating = false;
        if(button){
          button.disabled = false;
          button.textContent = 'Generate Story';
        }
      });
  }

  // Poll status every second
  setInterval(()=>{
    fetch('/api/status')
      .then(r=>r.json())
      .then(s=>{
        document.getElementById('fps').textContent = s.fps + ' FPS';
        const catalog = Array.isArray(s.overlays) ? s.overlays : [];
        const catalogChanged = JSON.stringify(catalog) !== JSON.stringify(overlayCatalog);
        if(catalogChanged){
          overlayCatalog = catalog;
          rebuildOverlayButtons(overlayCatalog);
        }
        activeOverlays = Array.isArray(s.active_overlays) ? s.active_overlays : [];
        const activeSet = new Set(activeOverlays);
        nudgeMode = !!s.nudge;
        if(Object.prototype.hasOwnProperty.call(s, 'nudge_target')){
          nudgeTarget = s.nudge_target;
        }
        if(Object.prototype.hasOwnProperty.call(s, 'nudge_config')){
          nudgeConfig = s.nudge_config;
        }
        nudgeMessage = s.nudge_message || '';
        if(Object.prototype.hasOwnProperty.call(s, 'story_text')){
          if(s.story_text !== storyText){
            storyText = s.story_text || '';
            updateStoryBox();
          }
        }
        currentMode = s.mode;
        prodFrozen = !!s.prod_frozen;
        prodWaiting = !!s.prod_waiting;

        let overlayNeedsSync = false;
        if(catalogChanged){
          if(selectedCharacterOverlay && !overlayCatalog.includes(selectedCharacterOverlay)){
            selectedCharacterOverlay = null;
            overlayNeedsSync = true;
          }
          if(selectedFoodOverlay && !overlayCatalog.includes(selectedFoodOverlay)){
            selectedFoodOverlay = null;
            overlayNeedsSync = true;
          }
        }

        if(selectedCharacterOverlay && !activeSet.has(selectedCharacterOverlay)){
          overlayNeedsSync = true;
        }
        if(selectedFoodOverlay && !activeSet.has(selectedFoodOverlay)){
          overlayNeedsSync = true;
        }

        if(!selectedCharacterOverlay && characterOverlayPrefix){
          const hasCharacterMatch = overlayCatalog.some(name=>overlayMatchesPrefix(name, characterOverlayPrefix));
          if(hasCharacterMatch){
            overlayNeedsSync = true;
          }
        }
        if(!selectedFoodOverlay && foodOverlayPrefix){
          const hasFoodMatch = overlayCatalog.some(name=>overlayMatchesPrefix(name, foodOverlayPrefix));
          if(hasFoodMatch){
            overlayNeedsSync = true;
          }
        }

        if(overlayNeedsSync && !storyOverlayInFlight){
          applyStoryOverlays();
        }

        updateUi();
      })
      .catch(()=>{});
  }, 1000);

  setInterval(fetchStory, 3000);
  fetchStory();
  updateStoryBox();

  function toggleMode(){
    const next = currentMode === 'prod' ? 'dev' : 'prod';
    fetch('/api/set_mode?mode='+next, {method:'POST'}).then(()=>{
      currentMode = next;
      if(next === 'dev'){
        prodFrozen = false;
        prodWaiting = false;
      }
      updateUi();
    });
  }

  // initialize UI to match defaults
  updateUi();
  updateNudgePanel();
  const initialNameEl = document.getElementById('storyNameInput');
  if(initialNameEl){
    storyNameInput = initialNameEl.value.trim();
  }
  const initialCharacterEl = document.getElementById('storyCharacterSelect');
  const initialFoodEl = document.getElementById('storyFoodSelect');
  storyCharacter = initialCharacterEl ? (initialCharacterEl.value || '') : '';
  storyFood = initialFoodEl ? (initialFoodEl.value || '') : '';
  characterOverlayPrefix = (characterOverlayMap[storyCharacter] || '').toUpperCase();
  foodOverlayPrefix = (foodOverlayMap[storyFood] || '').toUpperCase();
  selectedCharacterOverlay = null;
  selectedFoodOverlay = null;
  applyStoryOverlays();
  </script>
  <div style="padding:20px;
              display:flex;
              justify-content:center;">
    <button type="button" id="resetBtn" onclick="resetProd()"
            style="font-size:28px; padding:16px 28px; border-radius:16px; background:#ff7518; color:#111; border:none; cursor:pointer; font-weight:700;">
      Reset
    </button>
  </div>
  <div id="fpsBox" style="position:fixed; right:10px; top:10px; color:#0f0; font-weight:bold">FPS: <span id="fps">-</span></div>
</body>
</html>